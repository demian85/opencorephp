<?php

//namespace db;

/**
 * Represents a database result set, which is usually generated by executing a statement that queries the database.
 * The result set can also be divided into pages if the property $pageCount is greater than 0.
 *
 * @package db
 * @author Demián Andrés Rodriguez (demian85@gmail.com)
 */
abstract class ResultSet implements Iterator
{
	/**
	 * Specifies that the fetch method shall return each row as an array indexed by column name as returned in the corresponding result set.
	 * If the result set contains multiple columns with the same name, FETCH_ASSOC returns only a single value per column name.
	 * @var int
	 */
	const FETCH_ASSOC = 1;
	/**
	 * Specifies that the fetch method shall return each row as an array indexed by column number as returned in the corresponding result set, starting at column 0. 
	 * @var int
	 */
	const FETCH_NUM = 2;
	/**
	 * Specifies that the fetch method shall return each row as an array indexed by both column name and number as returned in the corresponding result set, starting at column 0. 
	 * @var int
	 */
	const FETCH_BOTH = 3;
	/**
	 * Specifies that the fetch method shall return each row as an object with property names that correspond to the column names returned in the result set. 
	 * @var int
	 */
	const FETCH_OBJ = 8;
	/**
	 * Specifies the fetch method to assign the values of the columns in the result set to the PHP variables to which they were bound with the bindParam() or bindColumn() methods. 
	 * @var int
	 */
	const FETCH_BOUND = 16;
	/**
	 * Specifies default fetch mode for this result.
	 * @var int
	 */
	protected $fetchMode = self::FETCH_ASSOC;
	/**
	 * Reference to current fetched row.
	 * @var mixed[]
	 */
	protected $currentRow = null;
	/**
	 * Indicates number of pages in this result set.
	 * @var int
	 */
	protected $pageCount;
	/**
	 * For paged result sets, this property indicates the total number of rows in the result set.
	 * @var int
	 */
	protected $fullRowCount;
	
	/**
	 * Constructor.
	 *
	 * @param int $pageCount Number of pages in this result set. 0 indicates no pagination.
	 * @param int $fullRowCount Total number fo rows in this result set. -1 indicates no pagination.
	 * @throws InvalidArgumentException if $pageCount or $fullRowCount are invalid.
	 */
	protected function __construct($pageCount = 0, $fullRowCount = -1)
	{
		$this->pageCount = (int)$pageCount;
		if ($this->pageCount < 0) {
			throw new InvalidArgumentException("Invalid page count. $pageCount is not >= 0.");
		}
		$this->fullRowCount = (int)$fullRowCount;
		if ($this->fullRowCount < -1) {
			throw new InvalidArgumentException("Invalid row count. $fullRowCount is not >= -1.");
		}
		if ($this->pageCount > 0 && $this->fullRowCount < 0) {
			throw new InvalidArgumentException("Invalid page or row count. $fullRowCount must be >= 0 if result set is paged.");
		}
	}
	
	/**
	 * Bind a column to a PHP variable.
	 * Arranges to have a particular variable bound to a given column in the result-set from a query.
	 * Each call to fetch() or fetchAll() will update all the variables that are bound to columns. 
	 *
	 * @param string|int $column Indexed columns are 0-based
	 * @param mixed $var
	 * @return void
	 * @throws SQLException
	 */
	abstract public function bindColumn($column, &$var);
	
	/**
	 * Fetches the next row from this result set. If no rows found, null is returned.
	 * For bound columns, this method should return a boolean indicating if a row has been fetched.
	 * // TODO implement FETCH_BOUND for stored procedures
	 *
	 * @param int $mode
	 * @return mixed[]|boolean
	 * @throws SQLException
	 */
	abstract public function fetch($mode = 0);
	
	/**
	 * Returns a single column from the next row. If no rows are found, null is returned.
	 * @param int $index 0-indexed number of the column you wish to retrieve from the row.
	 * @return mixed
	 * @throws SQLException
	 */
	abstract public function fetchColumn($index = 0);
	
	/**
	 * Fetches the next row as an object with the column names as its properties. Returns NULL is there are no rows.
	 * Alias of #fetch using FETCH_OBJ mode if $class is NULL.
	 * If $class is provided, that class will be instantiated and passed the fetched row (as an associative aray) as the first constructor parameter.
	 * $params are additional parameters for the constructor.
	 *
	 * @param string $class
	 * @param mixed[] $params
	 * @return object stdClass or a $class object
	 * @throws SQLException
	 */
	public function fetchObject($class = null, array $params = array())
	{
		if (!$class || $class == 'stdClass') {
			return $this->fetch(self::FETCH_OBJ);
		}

		$row = $this->fetch(self::FETCH_ASSOC);

		if (!$row) return null;
		
		if (empty($params)) {
			return new $class($row);
		}
		else {
			$ref = new ReflectionClass($class);
			array_unshift($params, $row);
			return $ref->newInstanceArgs($params);
		}
	}

	/**
	 * Alias of #fetchObject but returns an instance of ArrayObject.
	 *
	 * @return ArrayObject
	 * @throws SQLException
	 * @see #fetchObject
	 */
	public function fetchArrayObject()
	{
		return $this->fetchObject("ArrayObject", array(ArrayObject::ARRAY_AS_PROPS));
	}
	
	/**
	 * Fetch all rows.
	 *
	 * @param int $mode
	 * @return mixed[][]
	 * @throws SQLException
	 */
	public function fetchAll($mode = 0)
	{
		$data = array();
		$m = ($mode == 0) ? $this->fetchMode : $mode;
		while ($row = $this->fetch($m)) {
			$data[] = $row;
		}
		return $data;
	}

	/**
	 * Fetch all rows as objects. Same behavior as #fetchObject.
	 *
	 * @param string $class
	 * @param mixed[] $params
	 * @return mixed[][]
	 * @throws SQLException
	 * @see #fetchObject
	 */
	public function fetchAllObjects($class = null, array $params = array())
	{
		$data = array();

		if (!$class || $class == 'stdClass') {
			while ($object = $this->fetch(self::FETCH_OBJ)) {
				$data[] = $object;
			}
		}
		else {
			if (empty($params)) {
				while ($row = $this->fetch(self::FETCH_ASSOC)) {
					$data[] = new $class($row);
				}
			}
			else {
				$ref = new ReflectionClass($class);				
				while ($row = $this->fetch(self::FETCH_ASSOC)) {
					$_params = $params;
					array_unshift($_params, $row);
					$data[] = $ref->newInstanceArgs($_params);
				}
			}
		}

		return $data;
	}
	
	/**
	 * Fetch all rows as key pairs.
	 * If the result contains a single column, an array with its values will be returned.
	 * If the result contains 2 columns, each row will be an assoc array where the key is the value from the 1st column and the value will be the value from the 2nd column.
	 * If the number of columns is greater than 2, the value will be an array with the values from all the subsequent columns.
	 * 
	 * @return mixed[][]
	 * @throws SQLException
	 */
	public function fetchAllPairs()
	{
		$data = array();
		$cols = $this->columnCount();
		if ($cols == 1) {
			while ($row = $this->fetch(self::FETCH_NUM)) {
				$data[] = $row[0];
			}
		}
		else if ($cols == 2) {
			while ($row = $this->fetch(self::FETCH_NUM)) {
				$data[$row[0]] = $row[1];
			}
		}
		else {
			while ($row = $this->fetch(self::FETCH_NUM)) {
				$_key = array_shift($row);
				$data[$_key] = $row;
			}
		}
			
		return $data;
	}
	
	/**
	 * Returns the number of rows in the result set.
	 * For paged result sets, this method returns the number of rows for the current page.
	 *
	 * @return int
	 * @throws SQLException
	 */
	abstract public function rowCount();
	
	/**
	 * Returns the number of columns in the result set. 
	 *
	 * @return int
	 * @throws SQLException
	 */
	abstract public function columnCount();
	
	/**
	 * Adjusts the result pointer to an arbitary row in the result.
	 *
	 * @param int $rowIndex index between 0 and rowCount()-1
	 * @return void
	 * @throws SQLException
	 */
	abstract public function seek($rowIndex);
	
	/**
	 * Frees the memory associated with this result set.
	 *
	 * @return void
	 * @throws SQLException
	 */
	abstract public function close();
	
	/**
	 * Set fetch mode, mainly used for iteration.
	 * Use one of this class' constants FETCH_*
	 *
	 * @param int $mode
	 * @return void
	 */
	public function setFetchMode($mode)
	{
		$this->fetchMode = $mode;
	}
	
	/**
	 * Iterator:valid()
	 *
	 * @return boolean
	 */
	public function valid()
	{
		return ($this->currentRow != null);
	}
	
	/**
	 * Iterator::current()
	 *
	 * @return mixed[]|null
	 */
	public function current()
	{
		return $this->currentRow;
	}
	
	/**
	 * Iterator::rewind()
	 * 
	 * @return void
	 * @throws SQLException
	 */
	public function rewind()
	{
		if ($this->rowCount() > 0) {
			$this->seek(0);
		}
		$this->next();
	}
	
	/**
	 * Iterator::next()
	 *
	 * @return void
	 * @throws SQLException
	 */
	public function next()
	{
		$this->currentRow = $this->fetch();
	}
	
	/**
	 * Iterator::key()
	 *
	 * @return null
	 */
	public function key()
	{
		return null;
	}
	
	/**
	 * Get page count. 0 indicates a non-paged result set.
	 *
	 * @return int
	 */
	public function getPageCount()
	{
		return $this->pageCount;
	}
	
	/**
	 * Get total number of rows. -1 indicates a non-paged result set.
	 *
	 * @return int
	 */
	public function getFullRowCount()
	{
		return $this->fullRowCount;
	}
}
?>
